class OrganicSoundController {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.5;
        this.masterGain.connect(this.ctx.destination);
        this.musicPlaying = false;

        // 1. White / Pink / Brown Noise Generation
        this.bufferSize = this.ctx.sampleRate * 2; // 2 seconds

        // Brown Noise (Deep rumbling)
        this.brownNoiseBuffer = this.ctx.createBuffer(1, this.bufferSize, this.ctx.sampleRate);
        const brownOutput = this.brownNoiseBuffer.getChannelData(0);
        let lastOut = 0;
        for (let i = 0; i < this.bufferSize; i++) {
            const white = Math.random() * 2 - 1;
            lastOut = (lastOut + (0.02 * white)) / 1.02;
            brownOutput[i] = lastOut * 3.5; // Compensate gain
        }

        // Pink Noise (Texture)
        this.pinkNoiseBuffer = this.ctx.createBuffer(1, this.bufferSize, this.ctx.sampleRate);
        const pinkOutput = this.pinkNoiseBuffer.getChannelData(0);
        let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
        for (let i = 0; i < this.bufferSize; i++) {
            const white = Math.random() * 2 - 1;
            b0 = 0.99886 * b0 + white * 0.0555179;
            b1 = 0.99332 * b1 + white * 0.0750759;
            b2 = 0.96900 * b2 + white * 0.1538520;
            b3 = 0.86650 * b3 + white * 0.3104856;
            b4 = 0.55000 * b4 + white * 0.5329522;
            b5 = -0.7616 * b5 - white * 0.0168980;
            pinkOutput[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
            pinkOutput[i] *= 0.11;
            b6 = white * 0.115926;
        }

        // GOT Theme Sequence (Keep logic)
        this.melody = [
            [196.00, 4], [261.63, 4], [311.13, 1], [349.23, 1], [196.00, 2],
            [261.63, 2], [311.13, 1], [349.23, 1], [146.83, 8],
            [196.00, 4], [261.63, 4], [311.13, 1], [349.23, 1], [196.00, 2],
            [261.63, 2], [311.13, 1], [349.23, 1], [146.83, 8]
        ];
        this.noteIndex = 0;
        this.nextNoteTime = 0;
        this.tempo = 0.25;
    }

    resume() {
        if (this.ctx.state === 'suspended') this.ctx.resume();
        if (!this.musicPlaying) {
            this.playMusic();
            this.musicPlaying = true;
        }
    }

    playMusic() {
        const schedule = () => {
            if (!this.musicPlaying) return;
            while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
                this.playNote(this.melody[this.noteIndex]);
                this.noteIndex = (this.noteIndex + 1) % this.melody.length;
            }
            requestAnimationFrame(schedule);
        };
        this.nextNoteTime = this.ctx.currentTime + 0.1;
        schedule();
    }

    playNote([freq, duration]) {
        // Cello/String Layer - Keep tonal music but soft
        const t = this.ctx.currentTime;
        const noteLen = duration * this.tempo;

        const osc1 = this.ctx.createOscillator();
        osc1.type = 'sawtooth';
        osc1.frequency.value = freq;

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(600, t);

        const gain = this.ctx.createGain();
        osc1.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);

        gain.gain.setValueAtTime(0, this.nextNoteTime);
        gain.gain.linearRampToValueAtTime(0.15, this.nextNoteTime + 0.1);
        gain.gain.setValueAtTime(0.15, this.nextNoteTime + noteLen - 0.1);
        gain.gain.linearRampToValueAtTime(0, this.nextNoteTime + noteLen);

        osc1.start(this.nextNoteTime);
        osc1.stop(this.nextNoteTime + noteLen);

        this.nextNoteTime += noteLen;
    }

    playJump() {
        this.resume();
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        osc.frequency.setValueAtTime(40, t);
        osc.frequency.exponentialRampToValueAtTime(10, t + 0.3);
        osc.type = 'triangle';
        const oscGain = this.ctx.createGain();
        oscGain.gain.setValueAtTime(0, t);
        oscGain.gain.linearRampToValueAtTime(0.8, t + 0.05);
        oscGain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
        osc.connect(oscGain);
        oscGain.connect(this.masterGain);
        osc.start(t);
        osc.stop(t + 0.4);
        const src = this.ctx.createBufferSource();
        src.buffer = this.brownNoiseBuffer;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(150, t);
        filter.frequency.linearRampToValueAtTime(50, t + 0.6);
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.5, t + 0.1);
        gain.gain.linearRampToValueAtTime(0, t + 0.6);
        src.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        src.start(t);
        src.stop(t + 0.6);
    }

    playScore() {
        this.resume();
        const t = this.ctx.currentTime;
        const src = this.ctx.createBufferSource();
        src.buffer = this.pinkNoiseBuffer;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = 1.0;
        filter.frequency.setValueAtTime(200, t);
        filter.frequency.exponentialRampToValueAtTime(800, t + 0.15);
        filter.frequency.exponentialRampToValueAtTime(100, t + 0.4);
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.3, t + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
        src.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        src.start(t);
        src.stop(t + 0.4);
    }

    playCrack() {
        this.resume();
        const t = this.ctx.currentTime;
        const thudOsc = this.ctx.createOscillator();
        thudOsc.type = 'triangle';
        thudOsc.frequency.setValueAtTime(60, t);
        thudOsc.frequency.exponentialRampToValueAtTime(10, t + 0.2);
        const thudGain = this.ctx.createGain();
        thudGain.gain.setValueAtTime(0.6, t);
        thudGain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
        thudOsc.connect(thudGain);
        thudGain.connect(this.masterGain);
        thudOsc.start(t);
        thudOsc.stop(t + 0.2);
        const debrisSrc = this.ctx.createBufferSource();
        debrisSrc.buffer = this.brownNoiseBuffer;
        const debrisFilter = this.ctx.createBiquadFilter();
        debrisFilter.type = 'lowpass';
        debrisFilter.frequency.value = 150;
        const debrisGain = this.ctx.createGain();
        debrisGain.gain.setValueAtTime(0.5, t);
        debrisGain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
        debrisSrc.connect(debrisFilter);
        debrisFilter.connect(debrisGain);
        debrisGain.connect(this.masterGain);
        debrisSrc.start(t);
        debrisSrc.stop(t + 0.3);
    }

    playExplosion() {
        this.resume();
        const t = this.ctx.currentTime;
        const src = this.ctx.createBufferSource();
        src.buffer = this.pinkNoiseBuffer;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(400, t);
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.4, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
        src.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        src.start(t);
        src.stop(t + 0.15);
    }

    playFire() {
        this.resume();
        const t = this.ctx.currentTime;
        const roarOsc = this.ctx.createOscillator();
        roarOsc.type = 'sawtooth';
        roarOsc.frequency.setValueAtTime(80, t);
        roarOsc.frequency.exponentialRampToValueAtTime(40, t + 0.5);
        const roarFilter = this.ctx.createBiquadFilter();
        roarFilter.type = 'lowpass';
        roarFilter.frequency.value = 200;
        const roarGain = this.ctx.createGain();
        roarGain.gain.setValueAtTime(0, t);
        roarGain.gain.linearRampToValueAtTime(0.4, t + 0.05);
        roarGain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
        roarOsc.connect(roarFilter);
        roarFilter.connect(roarGain);
        roarGain.connect(this.masterGain);
        roarOsc.start(t);
        roarOsc.stop(t + 0.5);
        const fireSrc = this.ctx.createBufferSource();
        fireSrc.buffer = this.pinkNoiseBuffer;
        const fireFilter = this.ctx.createBiquadFilter();
        fireFilter.type = 'highpass';
        fireFilter.frequency.setValueAtTime(800, t);
        fireFilter.frequency.exponentialRampToValueAtTime(400, t + 0.4);
        const fireGain = this.ctx.createGain();
        fireGain.gain.setValueAtTime(0, t);
        fireGain.gain.linearRampToValueAtTime(0.5, t + 0.1);
        fireGain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
        fireSrc.connect(fireFilter);
        fireFilter.connect(fireGain);
        fireGain.connect(this.masterGain);
        fireSrc.start(t);
        fireSrc.stop(t + 0.4);
    }

    playTheme() {
        if (this.themePlaying) return;
        this.themePlaying = true;
        this.resume();
        const bpm = 90;
        const beat = 60 / bpm;
        let noteTime = this.ctx.currentTime + 0.2;
        const melody = [
            { f: 196.00, d: beat * 2 }, // G3
            { f: 130.81, d: beat * 2 }, // C3
            { f: 155.56, d: beat * 0.5 }, // Eb3
            { f: 174.61, d: beat * 0.5 }, // F3
            { f: 196.00, d: beat * 1.5 }, // G3
            { f: 130.81, d: beat * 1.5 }, // C3
            { f: 155.56, d: beat * 0.5 }, // Eb3
            { f: 174.61, d: beat * 0.5 }, // F3 
            { f: 146.83, d: beat * 4 },   // D3 (Hold)
            { f: 174.61, d: beat * 2 }, // F3
            { f: 116.54, d: beat * 2 }, // Bb2
            { f: 138.59, d: beat * 0.5 }, // Db3
            { f: 146.83, d: beat * 0.5 }, // D3
            { f: 174.61, d: beat * 1.5 }, // F3
            { f: 116.54, d: beat * 1.5 }, // Bb2
            { f: 138.59, d: beat * 0.5 }, // Db3
            { f: 146.83, d: beat * 0.5 }, // D3
            { f: 130.81, d: beat * 4 },   // C3 (End/Repeat)
        ];
        const scheduleLoop = () => {
            if (!this.themePlaying) return;
            noteTime = Math.max(noteTime, this.ctx.currentTime + 0.1); // Sync

            melody.forEach(note => {
                this.playCelloNote(note.f, noteTime, note.d);
                noteTime += note.d;
            });
            const totalDuration = melody.reduce((acc, n) => acc + n.d, 0);
            this.themeTimeout = setTimeout(scheduleLoop, (totalDuration * 1000) - 50);
        };
        scheduleLoop();
    }

    playCelloNote(freq, time, duration) {
        if (!this.themePlaying) return;
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(freq, time);
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(600, time);
        filter.frequency.linearRampToValueAtTime(400, time + duration); // Tone decay
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(0.15, time + 0.1); // Attack
        gain.gain.setValueAtTime(0.12, time + duration * 0.8); // Sustain
        gain.gain.exponentialRampToValueAtTime(0.001, time + duration + 0.1); // Release
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        osc.start(time);
        osc.stop(time + duration + 0.2);
    }

    stopTheme() {
        this.themePlaying = false;
        if (this.themeTimeout) clearTimeout(this.themeTimeout);
    }
}

class InputHandler {
    constructor() {
        this.jumpPressed = false;
        window.addEventListener('touchstart', (e) => this.onInput(e), { passive: false });
        window.addEventListener('mousedown', (e) => this.onInput(e));
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') this.onInput(e);
            if (e.key === 'k' || e.key === 'K') {
                if (game && game.currentState === 'playing') game.shoot();
            }
        });
    }
    onInput(e) {
        if (e.type !== 'keydown' || e.code === 'Space') { }
        if (game) game.sounds.resume();
        if (game && game.currentState === 'playing') {
            game.dragon.flap();
            game.sounds.playJump();
        } else if (game && game.currentState === 'gameover') {
            game.resetGame();
        }
    }
}

const DRAGONS = {
    balerion: { name: "Balerion", img: "assets/dragon_balerion.png", color: "#333", scale: 1.6 },
    drogon: { name: "Drogon", img: "assets/dragon_drogon.png", color: "#8b0000", scale: 1.0 },
    caraxes: { name: "Caraxes", img: "assets/dragon_caraxes.png", color: "#ff0000", scale: 1.0 },
    viserion: { name: "Viserion", img: "assets/dragon_viserion.png", color: "#ffd700", scale: 1.0 },
    meleys: { name: "Meleys", img: "assets/dragon_meleys.png", color: "#e63946", scale: 0.9, frames: 1 }
};

const KINGDOMS = {
    stark: { name: "House Stark", bg: "assets/bg_stark.png", obs: "assets/obs_stark_v3.png", color: "#8d99ae" },
    lannister: { name: "House Lannister", bg: "assets/bg_lannister.png", obs: "assets/obs_lannister_v3.png", color: "#d90429" },
    baratheon: { name: "House Baratheon", bg: "assets/bg_baratheon.png", obs: "assets/obs_baratheon_v3.png", color: "#ffb703" },
    greyjoy: { name: "House Greyjoy", bg: "assets/bg_greyjoy.png", obs: "assets/obs_greyjoy_v3.png", color: "#2b2d42" },
    tyrell: { name: "House Tyrell", bg: "assets/bg_tyrell.png", obs: "assets/obs_tyrell_v3.png", color: "#2d6a4f" },
    martell: { name: "House Martell", bg: "assets/bg_martell.png", obs: "assets/obs_martell_v3.png", color: "#e36414" },
    targaryen: { name: "House Targaryen", bg: "assets/bg_targaryen.png", obs: "assets/obs_targaryen_v3.png", color: "#000000" },
    arryn: { name: "House Arryn", bg: "assets/bg_arryn.png", obs: "assets/obs_arryn_v3.png", color: "#8ecae6" }
};

class Obstacle {
    constructor(canvas, imageSrc) {
        this.canvas = canvas;
        this.x = canvas.width;
        this.width = 70;
        this.gap = 210;
        this.topHeight = Math.random() * (canvas.height - this.gap - 100) + 50;
        this.passed = false;
        this.image = new Image();
        this.image.src = imageSrc;
    }
    draw(ctx) {
        if (this.image.complete && this.image.naturalWidth !== 0) {
            const imgW = this.width;
            const scale = this.width / this.image.naturalWidth;
            const imgH = this.image.naturalHeight * scale;
            let currentY = this.topHeight - imgH;
            while (currentY > -imgH) {
                ctx.drawImage(this.image, this.x, currentY, imgW, imgH);
                currentY -= imgH;
            }
            currentY = this.topHeight + this.gap;
            while (currentY < this.canvas.height) {
                ctx.drawImage(this.image, this.x, currentY, imgW, imgH);
                currentY += imgH;
            }
        } else {
            ctx.fillStyle = '#555';
            ctx.fillRect(this.x, 0, this.width, this.topHeight);
            ctx.fillRect(this.x, this.topHeight + this.gap, this.width, this.canvas.height - (this.topHeight + this.gap));
        }
    }
}

class Dragon {
    constructor(canvas, imageSrc, scale = 1.0, totalFrames = 6) {
        this.canvas = canvas;
        this.scale = scale;
        this.x = 50;
        this.y = canvas.height / 2;
        this.velocity = 0;
        this.gravity = 0.4;
        this.jumpStrength = -7;
        this.radius = 25 * this.scale;
        this.spritesheet = new Image();
        this.spritesheet.src = (imageSrc || 'assets/vhagar_sheet_new.png') + '?v=' + Date.now();
        this.totalFrames = totalFrames;
        this.frameWidth = 0;
        this.frameHeight = 0;
        this.flapTimer = 0;
    }
    draw(ctx) {
        if (this.spritesheet.complete && this.spritesheet.naturalWidth !== 0) {
            if (this.frameWidth === 0) {
                this.frameWidth = this.spritesheet.width / this.totalFrames;
                this.frameHeight = this.spritesheet.height;
            }
            let speed = 100;
            if (this.velocity < -2) speed = 70;
            else if (this.velocity > 2) speed = 200;
            const frameIndex = Math.floor(Date.now() / speed) % this.totalFrames;
            const sx = frameIndex * this.frameWidth;
            ctx.save();
            ctx.translate(this.x, this.y);
            let rotation = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, (this.velocity * 0.1)));
            ctx.rotate(rotation);
            ctx.imageSmoothingEnabled = false;
            const aspect = this.frameWidth / this.frameHeight;
            const drawHeight = 120 * this.scale;
            const drawWidth = drawHeight * aspect;
            ctx.drawImage(this.spritesheet, sx, 0, this.frameWidth, this.frameHeight, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
            ctx.restore();
        } else {
            ctx.fillStyle = '#aa0000';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    update() {
        this.velocity += this.gravity;
        this.y += this.velocity;
        this.flapTimer++;
    }
    flap() {
        this.velocity = this.jumpStrength;
    }
}

class Projectile {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.radius = 6;
        this.active = true;
        if (type === 'fire') { this.vx = 12; this.vy = 0; }
        else if (type === 'ice') { this.vx = -8; this.vy = 0; }
        else if (type === 'ice-arc') { this.vx = -6; this.vy = -5; }
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        if (this.type === 'ice-arc') this.vy += 0.2;
        if (this.x > window.innerWidth + 50 || this.x < -50 || this.y > window.innerHeight + 50) this.active = false;
    }
    draw(ctx) {
        ctx.save();
        if (this.type === 'fire') {
            const baseRadius = 8;
            const time = Date.now() * 0.01;
            ctx.beginPath();
            ctx.fillStyle = 'rgba(255, 100, 0, 0.3)';
            ctx.shadowColor = '#ff6600';
            ctx.shadowBlur = 20;
            ctx.arc(this.x, this.y, baseRadius + 8 + Math.sin(time) * 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, baseRadius + 4);
            gradient.addColorStop(0, '#ffff00');
            gradient.addColorStop(0.4, '#ff8800');
            gradient.addColorStop(0.7, '#ff4500');
            gradient.addColorStop(1, 'rgba(255, 69, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.shadowColor = '#ffaa00';
            ctx.shadowBlur = 10;
            ctx.arc(this.x, this.y, baseRadius + 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            const coreGradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, baseRadius);
            coreGradient.addColorStop(0, '#ffffff');
            coreGradient.addColorStop(0.3, '#ffffaa');
            coreGradient.addColorStop(0.6, '#ffcc00');
            coreGradient.addColorStop(1, '#ff6600');
            ctx.fillStyle = coreGradient;
            ctx.shadowColor = '#ffff00';
            ctx.shadowBlur = 5;
            ctx.arc(this.x, this.y, baseRadius, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.beginPath();
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00aaff';
            ctx.shadowBlur = 10;
            ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.lineWidth = 1.5;
            ctx.strokeStyle = '#ffffff';
            ctx.stroke();
        }
        ctx.restore();
    }
}

class Enemy {
    constructor(canvas, type = 'warrior') {
        this.canvas = canvas;
        this.image = new Image();
        this.image.src = 'assets/ice_dragon_v2.png?v=' + Date.now();
        this.type = type;
        this.width = 70;
        this.height = 50;
        this.speed = 3 + Math.random() * 2;
        if (type === 'scout') { this.width = 50; this.height = 35; this.speed = 6 + Math.random() * 2; }
        else if (type === 'boss') { this.width = 120; this.height = 90; this.speed = 1.5; }
        this.x = canvas.width + 50;
        this.y = Math.random() * (canvas.height - 200) + 100;
        this.active = true;
        this.oscillationOffset = Math.random() * 100;
        this.shootTimer = 0;
    }
    update(game) {
        this.x -= this.speed;
        this.y += Math.sin((this.x + this.oscillationOffset) * 0.05) * 2;
        if (this.x < -150) this.active = false;
        if (this.type !== 'scout') {
            this.shootTimer++;
            const fireRate = this.type === 'boss' ? 80 : 150;
            if (this.shootTimer > fireRate && Math.random() < 0.05) {
                const sy = this.y + this.height / 2;
                game.projectiles.push(new Projectile(this.x, sy, 'ice'));
                if (game.sounds) { try { game.sounds.playFire(); } catch (e) { } }
                this.shootTimer = 0;
            }
        }
    }
    draw(ctx) {
        ctx.save();
        ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
        if (this.image.complete && this.image.naturalWidth !== 0) {
            ctx.drawImage(this.image, -this.width / 2, -this.height / 2, this.width, this.height);
        } else {
            ctx.fillStyle = this.type === 'boss' ? '#00008b' : '#00ffff';
            ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
        }
        ctx.restore();
    }
}
class Game {
    constructor() {
        try {
            this.canvas = document.getElementById('gameCanvas');
            if (!this.canvas) throw new Error("Canvas not found");
            this.ctx = this.canvas.getContext('2d');
            this.sounds = new OrganicSoundController();
        } catch (e) {
            console.error(e);
        }
        this.currentKingdomKey = 'stark';
        this.currentDragonKey = 'balerion';
        this.bgImage = new Image();
        this.obstacleImageSrc = 'assets/obs_stark_v3.png';

        this.dragon = new Dragon(this.canvas);
        this.obstacles = [];
        this.projectiles = [];
        this.enemies = [];
        this.score = 0;
        this.frameCount = 0;
        this.currentState = 'menu';
        this.bgX = 0;
        this.baseSpeed = 3;
        this.currentSpeed = this.baseSpeed;

        this.ui = {
            start: document.getElementById('start-screen'),
            selection: document.getElementById('kingdom-selection'),
            dragonSelection: document.getElementById('dragon-selection'),
            gameOver: document.getElementById('game-over-screen'),
            score: document.getElementById('score-display'),
            finalScore: document.getElementById('final-score'),
            restartBtn: document.getElementById('restart-btn'),
            stamina: document.getElementById('stamina-bar'),
            staminaCont: document.getElementById('stamina-container'),
            highScore: document.getElementById('high-score'),
            bossHud: document.getElementById('boss-hud'),
            bossHp: document.getElementById('boss-hp-fill'),
            shootBtn: document.getElementById('shoot-btn')
        };

        this.resize();
        window.addEventListener('resize', () => this.resize());

        if (this.ui.restartBtn) {
            this.ui.restartBtn.addEventListener('click', () => this.resetGame());
        }

        const shootBtn = document.getElementById('shoot-btn');
        if (shootBtn) {
            shootBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                this.shoot();
            }, { passive: false });
            shootBtn.addEventListener('click', () => this.shoot());
        }

        const startBtn = document.getElementById('start-btn');
        if (startBtn) {
            startBtn.addEventListener('click', () => this.startGame());
        }

        this.initSelectionMenu();
        this.initDragonSelection();
        this.updateStartButton();
        new InputHandler();
    }

    
    initSelectionMenu() {
        if (!this.ui.selection) this.ui.selection = document.getElementById('kingdom-selection');
        if (!this.ui.selection) return;
        this.ui.selection.innerHTML = '';
        Object.keys(KINGDOMS).forEach(key => {
            const kingdom = KINGDOMS[key];
            const card = document.createElement('div');
            card.className = 'kingdom-card';
            card.innerHTML = `<img src="${kingdom.obs}" class="kingdom-icon"><div class="kingdom-name" style="color:${kingdom.color}">${kingdom.name}</div>`;
            card.style.borderColor = kingdom.color;
            if (key === this.currentKingdomKey) card.classList.add('selected');
            card.onclick = (e) => {
                e.stopPropagation();
                this.currentKingdomKey = key;
                this.loadAssets(key);
                this.ui.selection.querySelectorAll('.kingdom-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                this.updateStartButton();
            };
            this.ui.selection.appendChild(card);
        });
    }

    initDragonSelection() {
        if (!this.ui.dragonSelection) this.ui.dragonSelection = document.getElementById('dragon-selection');
        if (!this.ui.dragonSelection) return;
        this.ui.dragonSelection.innerHTML = '';
        Object.keys(DRAGONS).forEach(key => {
            const dragon = DRAGONS[key];
            const card = document.createElement('div');
            card.className = 'dragon-card';
            const frames = dragon.frames || 6;
            const bgPos = frames === 1 ? 'center' : '0 center';
            const bgSize = frames === 1 ? 'contain' : `${frames * 100}% auto`;
            card.innerHTML = `<div class="dragon-icon" style="background-image:url(${dragon.img}); background-size:${bgSize}; background-position:${bgPos}; display:block; width:80px; height:80px;"></div><div class="dragon-name" style="color:${dragon.color || '#fff'}">${dragon.name}</div>`;
            if (key === this.currentDragonKey) card.classList.add('selected');
            card.onclick = (e) => {
                e.stopPropagation();
                this.currentDragonKey = key;
                this.ui.dragonSelection.querySelectorAll('.dragon-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
            };
            this.ui.dragonSelection.appendChild(card);
        });
    }

    updateStartButton() {
        const btn = document.getElementById('start-btn');
        if (btn) btn.classList.remove('hidden');
    }
    
    loadAssets(key) {
        if(KINGDOMS[key]) {
             this.bgImage.src = KINGDOMS[key].bg;
             this.obstacleImageSrc = KINGDOMS[key].obs;
        }
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }

    resetGame() {
        this.startGame();
    }

    shoot() {
        if (this.currentState === 'playing' && this.stamina >= 20) {
            this.stamina -= 20;
            const fireX = this.dragon.x + 40;
            const fireY = this.dragon.y;
            this.projectiles.push(new Projectile(fireX, fireY, 'fire'));
            if (this.sounds) this.sounds.playFire();
            if (this.ui.stamina) this.ui.stamina.style.width = this.stamina + '%';
        }
    }

    startGame(kingdomKey) {
        if(kingdomKey) this.currentKingdomKey = kingdomKey;
        this.loadAssets(this.currentKingdomKey);
        const dConfig = DRAGONS[this.currentDragonKey];
        if (dConfig) this.dragon = new Dragon(this.canvas, dConfig.img, dConfig.scale || 1.0, dConfig.frames || 6);

        this.currentState = 'playing';
        this.score = 0;
        this.stamina = 100;
        this.obstacles = [];
        this.projectiles = [];
        this.enemies = [];
        this.frameCount = 0;
        this.bossMode = false;
        this.currentSpeed = this.baseSpeed;
        this.dragon.y = this.canvas.height / 2;
        this.dragon.velocity = 0;

        if (this.ui.start) {
            this.ui.start.classList.remove('active');
            this.ui.start.classList.add('hidden');
        }
        if (this.ui.selection) this.ui.selection.classList.add('hidden');
        if (this.ui.dragonSelection) this.ui.dragonSelection.classList.add('hidden');
        if (this.ui.gameOver) this.ui.gameOver.classList.add('hidden');
        if (this.ui.score) {
            this.ui.score.classList.remove('hidden');
            this.ui.score.innerText = '0';
        }
        if (this.ui.staminaCont) this.ui.staminaCont.classList.remove('hidden');
        if (this.ui.bossHud) this.ui.bossHud.classList.add('hidden');
        if (this.ui.shootBtn) this.ui.shootBtn.classList.remove('hidden');

        this.loop();
    }

    gameOver() {
        this.currentState = 'gameover';
        if (this.ui.gameOver) this.ui.gameOver.classList.remove('hidden');
        if (this.ui.score) this.ui.score.classList.add('hidden');
        if (this.ui.staminaCont) this.ui.staminaCont.classList.add('hidden');
        if (this.ui.shootBtn) this.ui.shootBtn.classList.add('hidden');
        if (this.ui.bossHud) this.ui.bossHud.classList.add('hidden');

        if (this.ui.finalScore) this.ui.finalScore.innerText = this.score;
        let hs = localStorage.getItem('flappyHighScore') || 0;
        if (this.score > hs) {
            hs = this.score;
            localStorage.setItem('flappyHighScore', hs);
        }
        if (this.ui.highScore) this.ui.highScore.innerText = hs;
    }

    update() {
        if (this.currentState !== 'playing') return;
        this.frameCount++;

        this.bgX -= this.currentSpeed * 0.5;
        if (this.bgX < -10000) this.bgX += 10000;

        if (this.frameCount % 10 === 0 && this.stamina < 100) {
            this.stamina += 2;
            if (this.stamina > 100) this.stamina = 100;
            if (this.ui.stamina) this.ui.stamina.style.width = this.stamina + '%';
        }

        this.dragon.update();

        if (this.dragon.y + this.dragon.radius > this.canvas.height || this.dragon.y - this.dragon.radius < 0) {
            if (this.sounds) this.sounds.playCrack();
            this.gameOver();
        }

        if (this.frameCount % 120 === 0 && !this.bossMode) {
            this.obstacles.push(new Obstacle(this.canvas, this.obstacleImageSrc || 'assets/obs_stark_v3.png'));
        }

        for (let i = this.obstacles.length - 1; i >= 0; i--) {
            let o = this.obstacles[i];
            o.x -= this.currentSpeed;
            if (o.x + o.width < 0) {
                this.obstacles.splice(i, 1);
                continue;
            }
            if (!o.passed && this.dragon.x > o.x + o.width) {
                o.passed = true;
                this.score++;
                if (this.ui.score) this.ui.score.innerText = this.score;
                if (this.sounds) this.sounds.playScore();

                if (this.score > 0 && this.score % 50 === 0) {
                    this.startBossBattle();
                }
            }
            if (
                this.dragon.x + this.dragon.radius > o.x &&
                this.dragon.x - this.dragon.radius < o.x + o.width &&
                (this.dragon.y - this.dragon.radius < o.topHeight || this.dragon.y + this.dragon.radius > o.topHeight + o.gap)
            ) {
                if (this.sounds) this.sounds.playCrack();
                this.gameOver();
            }
        }

        if (this.frameCount % 200 === 0 && !this.bossMode) {
            let type = Math.random() > 0.7 ? 'scout' : 'warrior';
            this.enemies.push(new Enemy(this.canvas, type));
        }

        if (this.boss && this.boss.active) {
            this.boss.update();
            const dx = this.dragon.x - (this.boss.x + this.boss.width / 2);
            const dy = this.dragon.y - (this.boss.y + this.boss.height / 2);
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < (this.dragon.radius + this.boss.width / 3)) {
                if (this.sounds) this.sounds.playCrack();
                this.gameOver();
            }
        }
            // Update Projectiles
            for (let i = this.projectiles.length - 1; i >= 0; i--) {
                const p = this.projectiles[i];
                p.update();

                // Collision: Projectile vs Player
                if ((p.type === 'ice' || p.type === 'ice-arc' || p.type === 'ice-target') && p.active) {
                    const dx = p.x - this.dragon.x;
                    const dy = p.y - this.dragon.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < this.dragon.radius + p.radius - 5) {
                        try { this.sounds.playCrack(); } catch (e) { }
                        this.gameOver();
                        p.active = false;
                    }
                }

                // Collision: Projectile vs Projectile (Fire vs Ice)
                for (let j = this.projectiles.length - 1; j >= 0; j--) {
                    if (i === j) continue;
                    const other = this.projectiles[j];
                    if (p.type !== other.type && p.active && other.active) {
                        const dx = p.x - other.x;
                        const dy = p.y - other.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < p.radius + other.radius) {
                            p.active = false;
                            other.active = false;
                            this.sounds.playExplosion();
                            break;
                        }
                    }
                }

                // Active check handled after loop or by splicing immediately loops backwards so its safe
                if (!p.active) {
                    this.projectiles.splice(i, 1);
                }
            }

            // Update Enemies
            for (let i = this.enemies.length - 1; i >= 0; i--) {
                const e = this.enemies[i];
                e.update(this);

                // Collision: Fireball vs Enemy
                for (let j = this.projectiles.length - 1; j >= 0; j--) {
                    const p = this.projectiles[j];
                    if (p.type === 'fire' && p.active) {
                        const dx = p.x - e.x - e.width / 2;
                        const dy = p.y - e.y - e.height / 2;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        // Hitbox depends on enemy size
                        if (dist < e.width / 2 + p.radius) {
                            this.sounds.playExplosion();
                            e.active = false;
                            p.active = false;
                            this.score += (e.type === 'boss' ? 20 : 5);
                            this.ui.score.innerText = this.score;
                            break;
                        }
                    }
                }



                // Collision: Player vs Enemy Body
                const dx = this.dragon.x - (e.x + e.width / 2);
                const dy = this.dragon.y - (e.y + e.height / 2);
                const dist = Math.sqrt(dx * dx + dy * dy);
                const collisionThreshold = (this.dragon.radius + e.width / 2) * 0.9;

                if (dist < collisionThreshold) {
                    this.sounds.playCrack();
                    this.gameOver();
                }

                if (!e.active) {
                    this.enemies.splice(i, 1);
                }
            }
        }
    }

    startBossBattle() {
        this.bossMode = true;
        this.boss = new Boss(this);

        // Show Boss UI
        if (this.ui.bossHud) {
            this.ui.bossHud.classList.remove('hidden');
            this.ui.bossHp.style.width = '100%';
        }
        if (this.ui.shootBtn) {
            this.ui.shootBtn.classList.remove('hidden');
        }

        // Clear screen of obstacles
        this.obstacles = [];
        this.enemies = []; // Clear other enemies

        // Visual Indicator
        const flash = document.createElement('div');
        flash.className = 'powerup-active'; // Reuse existing class for big text
        flash.innerText = "DRACARYS!";
        document.body.appendChild(flash);
        setTimeout(() => flash.remove(), 2000);

        // Flash screen red/orange
        this.ctx.save();
        this.ctx.fillStyle = 'rgba(255, 69, 0, 0.3)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.restore();
    }

    bossDefeated() {
        this.bossMode = false;
        this.boss = null;

        // Bonus Score
        this.score += 50;
        this.ui.score.innerText = this.score;
        this.stamina = 100;

        // Set next boss score relative to NEW score
        this.nextBossScore = this.score + 50;

        // Hide Boss UI
        if (this.ui.bossHud) this.ui.bossHud.classList.add('hidden');
        if (this.ui.shootBtn) this.ui.shootBtn.classList.add('hidden');

        // Ensure obstacles start spawning again immediately
        this.lastObstacleSpawn = 351; // Force immediate spawn in next update
    }

    draw() {
        // Clear background
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw Background
        if (this.bgImage.complete && this.bgImage.naturalWidth !== 0) {
            const scale = Math.max(1, this.canvas.height / this.bgImage.height);
            // Add +2 pixels to width to ensure overlap and cover seams
            const w = Math.ceil(this.bgImage.width * scale) + 2;
            const h = Math.ceil(this.bgImage.height * scale);
            const totalWidth = w - 2; // Real spacing logic, but we draw slightly wider
            let startIdx = Math.floor(-this.bgX / totalWidth);

            for (let i = 0; i < 4; i++) {
                let currentIdx = startIdx + i;
                // Use Math.floor to snap to pixels
                let drawX = Math.floor((currentIdx * totalWidth) + this.bgX);

                if (drawX > this.canvas.width) break;
                if (drawX + w < 0) continue;

                this.ctx.save();
                this.ctx.translate(drawX, 0);
                if (Math.abs(currentIdx) % 2 === 1) {
                    // Start from the slightly wider width endpoint for flipping
                    this.ctx.translate(w, 0);
                    this.ctx.scale(-1, 1);
                }
                // Draw slightly larger
                this.ctx.drawImage(this.bgImage, 0, 0, w, h);
                this.ctx.restore();
            }
        } else if (this.currentState !== 'menu') {
            this.ctx.fillStyle = '#87CEEB';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }

        if (this.currentState === 'playing' || this.currentState === 'gameover') {
            this.obstacles.forEach(obs => obs.draw(this.ctx));
            this.enemies.forEach(e => e.draw(this.ctx));
            if (this.boss) this.boss.draw(this.ctx);
            // Draw Dragon before projectiles so fire comes "out"
            this.dragon.draw(this.ctx);
            // Draw projectiles last to ensure they are ON TOP of everything
            this.projectiles.forEach(p => p.draw(this.ctx));
        }
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(this.loop);
    }
}

let game = null;
window.addEventListener('load', () => {
    game = new Game();
});


